# Full-stack webprogramoz√°s -- Testing REST APIs in Java Spring Boot

## Resources

- REST API testing
  - https://spring.io/guides/gs/testing-web/
  - https://dzone.com/articles/integration-testing-in-spring-boot-1
  - https://www.baeldung.com/spring-boot-testing
  - (https://howtodoinjava.com/spring-boot2/testing/spring-integration-testing/)
  - (https://www.javaguides.net/2018/09/spring-boot-2-rest-apis-integration-testing.html)
  - (https://www.springboottutorial.com/integration-testing-for-spring-boot-rest-services)
- Database-related
  - https://reflectoring.io/spring-boot-test/
  - https://reflectoring.io/spring-boot-data-jpa-test/
  - https://www.baeldung.com/spring-testing-separate-data-source

## Description

### First steps

If the initial application was generated by Spring Boot initializer, then the application already contains the necessary dependency for testing:

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</scope>
</dependency>
```

The next important information is that all test-related stuff should go under `src/test` directory. There you may have the very same folder structure as in your `src/main` folder. For example you can create a `resources` folder, and put an `application.properties` file, which will be read during the test start-up instead of the original one, which should be used in production.

Considering testing of REST APIs, there are several approach which you can follow. These approaches target different layers of your application during testing.

- whole server with `@SpringBootTest` annotation and `TestRestTemaplate`
- whole application without a server with `@AutoConfigureMockMvc` annotation and `MockMvc`
- only the web layer with mocked dependencies with `@WebMvcTest`, `MockMvc` and `@MockBean`

We will show examples on the first one, but you can read about the other approaches through the links above.

### Using a test database

First let us discuss the database layer. In production we would like to persist the data in the file system, while during testing using an in-memory database is much faster. So in production we use an `application.properties` file like this:

```
spring.jpa.hibernate.ddl-auto=validate
spring.datasource.platform=h2
spring.datasource.url=jdbc:h2:file:./issuedb
```

... and for the tests like this:

```
spring.jpa.hibernate.ddl-auto=create-drop
spring.datasource.platform=h2
spring.datasource.url=jdbc:h2:mem:issuedb
```

Spring Boot will drop all tables, and create them again between every test. Also it will use the `import.sql` or `data.sql` file from the `main` directory, so the test database will also be seeded every time a new test starts.

### Writing tests

For writing tests, create a new class in `src/test/your/app/` directory, e.g. `IssueControllerRestTest`:

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class IssueControllerRestTest {

  @LocalServerPort
  private int port;

  @Autowired
  private TestRestTemplate restTemplate;

  // Tests should go here...
}
```

First you give the `@SpringBootTest` annotation to the class indicating that start the server on a random port. This is good in CI test environments. We inject the generated random port as `port` data member into the class instance, and also ask a `TestRestTemplate` instance as well. In this scenario the whole application context will start with a development server, and we can send HTTP requests to this server with the help of the `restTemplate` data member. `restTemplate` has some useful methods for sending requests and prepare the response for checking:
- `getForObject` will try to serve the response as a specific object. Use `String.class` to get the answer as a string (e.g. a JSON string).
- `getForEntity` will give you back a `ResponseEntity` instance with a specified class. It is similar to the controller methods.
- `exchange` is similar to `getForEntity`, but you can further refine the mapping of the answer. Should be used in more complex scenarios.

Our first test checks whether all issues are returned or not. It uses the `exchange` method to map the response to a list of issues object. After that it checks the HTTP response code and the multiplicity of issues in the answer. Because the seed contains four records, we expect to return four issues.

```java
@Test
public void shouldReturnAllIssues() throws Exception {
  ResponseEntity<List<Issue>> response = restTemplate.exchange("http://localhost:" + port + "/issues", HttpMethod.GET, null, new ParameterizedTypeReference<List<Issue>>() {});
  assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
  assertThat(response.getBody().size()).isEqualTo(4);
}
```

The second test validates endpoint for getting a single issue entity. We use `getForEntity` here to check the response status and the issue:

```java
@Test
public void shouldReturnTheFirstIssue() throws Exception {
  ResponseEntity<Issue> response = restTemplate.getForEntity("http://localhost:" + port + "/issues/1", Issue.class);
  assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
  Issue issue = response.getBody();
  assertThat(issue.getTitle()).isEqualTo("issue1");
}
```

The next test is a variation of the latter one, but in this case it validates as a JSON string with the help of the `JSONAssert` library. This is part of the default Spring Boot test package.

```java
@Test
public void shouldReturnTheFirstIssueAsString() throws Exception {
  ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:" + port + "/issues/1", String.class);
  assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
  JSONAssert.assertEquals("{title:issue1,description:description1}", response.getBody(), false);
}
```

Finally we have a complex test to ensure that a posted issue is not only saved, but can be got it back later. First we check the multiplicity of all issues, then we post a new issue to the server and check the response entity. Finally we check the multiplicity again, and find that it is increased with 1.

```java
@Test
public void shouldSaveAPostedIssue() throws Exception {
  ResponseEntity<List<Issue>> response = restTemplate.exchange("http://localhost:" + port + "/issues", HttpMethod.GET, null, new ParameterizedTypeReference<List<Issue>>() {});
  assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
  assertThat(response.getBody().size()).isEqualTo(4);
  
  Issue issue = new Issue();
  issue.setTitle("new title");
  issue.setDescription("new description");
  issue.setPlace("new place");
  issue.setStatus(Issue.Status.NEW);
  
  ResponseEntity<Issue> responsePost = restTemplate.postForEntity("http://localhost:" + port + "/issues", issue, Issue.class);
  assertThat(responsePost.getStatusCode()).isEqualTo(HttpStatus.OK);
  assertThat(responsePost.getBody().getId()).isNotNull();
  assertThat(responsePost.getBody().getId()).isEqualTo(5);
  assertThat(responsePost.getBody().getTitle()).isEqualTo("new title");
  assertThat(responsePost.getBody().getDescription()).isEqualTo("new description");
  assertThat(responsePost.getBody().getPlace()).isEqualTo("new place");
  assertThat(responsePost.getBody().getStatus()).isEqualTo(Issue.Status.NEW);
  assertThat(responsePost.getBody().getCreated_at()).isNotNull();
  assertThat(responsePost.getBody().getUpdated_at()).isNotNull();
  
  ResponseEntity<List<Issue>> response2 = restTemplate.exchange("http://localhost:" + port + "/issues", HttpMethod.GET, null, new ParameterizedTypeReference<List<Issue>>() {});
  assertThat(response2.getStatusCode()).isEqualTo(HttpStatus.OK);
  assertThat(response2.getBody().size()).isEqualTo(5);
}
```

Note, that we do the same as we would do it manually. This is what end-to-end tests or functional tests are about. The next test would start again with four issues, because the tests are independent from each other.
